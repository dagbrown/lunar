#!/bin/bash
#                                                          #
# This code is written for Lunar Linux, see                #
# http://lunar-linux.org                                   #
#                                                          #
############################################################
#                                                          #
# $FUNCTIONS/modules                                       #
# includes create_module_index, find_section               #
#          list_sections, list_modules, list_installed     #
#          check_module_index, run_details                 #
#          module_installed, module_held, module_exiled    #
#          module_enforced, hold_modules, unhold_modules   #
#          exile_modules, unexile_modules, enforce_modules #
#          unenforce_modules                               #
# 20020528                                                 #
# 20030113 merging more functions in here - sofar          #
# 20030417 adding hold routines - sofar                    #
#                                                          #
############################################################
#                                                          #
# Copyrighted Kagan Kongar 2002 under GPLv2                #
# Portions Copyrighted Chuck Mead 2002 under GPLv2         #
# Portions Copyrighted Auke Kok 2003 under GPLv2           #
#                                                          #
############################################################


# function : list_sections
# usage    : list_sections
# purpose  : list the moonbase sections, filter out the specific files
list_sections() {
	debug_msg "list_sections ($@)"
	check_module_index
    sqlite3 $MODULE_STATUS 'select distinct(location) from module_index'
	find $MOONBASE/zlocal -name DETAILS | sed "s:^$MOONBASE\/::g;s:\/[^\/]*\/DETAILS$::g" | sort | uniq
	return 0
}


# function : list_modules
# usage    : list_modules $SECTION
# purpose  : list the modules in a section, filter out the specific files
list_modules() {
	debug_msg "list_modules ($@)"
	if [[ -z "$1" ]] ; then
		error_message "${PROBLEM_COLOR}list_modules(): no SECTION defined!${DEFAULT_COLOR}"
		exit 1
	fi

	if [[ ! -d $MOONBASE/$1 ]] ; then
		error_message "${PROBLEM_COLOR}list_modules(): no such section \"$1\"!${DEFAULT_COLOR}"
		exit 1
	fi

    if [[ $(sqlite3 $MODULE_STATUS "select count(*) from module_index where location = '$1'") != "0" ]]
    then
        sqlite3 $MODULE_STATUS "select package from module_index where location = '$1'"
		return 0
	else
	 (
		 cd $MOONBASE/$1
         for i in */DETAILS */*/DETAILS
         do
            [[ -f $i ]] && echo ${i%/DETAILS}
         done
	 )
	fi
}


# function : list_moonbase
# usage    : list_moonbase
# purpose  : returns the names of all modules in moonbase
list_moonbase() {
	local SECTION
	debug_msg "list_moonbase ($@)"
	for SECTION in $(list_sections) ; do
		list_modules $SECTION
	done
}


# function : list_installed
# usage    : list_installed
# purpose  : return a list of installed (or held) modules
list_installed() {
  debug_msg "list_installed ($@)"
  sqlite3 "$MODULE_STATUS" \
      "select distinct m.package
           from modules_states ms
           inner join modules m on ms.module_id = m.rowid
           inner join states s on ms.state_id = s.rowid
           where s.name = 'installed' or s.name = 'held'"
}


# function: create_module_index
# usage   : create_module_index
# purpose : created an index file of module:section pair list
create_module_index() {
  local TMP_INDEX
  debug_msg "create_module_index ($@)"

  verbose_msg "Updating module index file..."
  # doing this allows us to ctrl-C the process without breaking the
  # index file
  TMP_INDEX=$(temp_create "module.index")

  # here we have two options: system moonbase or custom:
  if [[ "$MOONBASE" == "/var/lib/lunar/moonbase" ]] &&
     [[ -f $INSTALL_LOGS/moonbase-$(installed_version moonbase) ]] ; then

    # short way out:
    debug_msg "Quick generating \$MODULE_INDEX..."
    grep "/DETAILS$" "$INSTALL_LOGS/moonbase-$(installed_version moonbase)" |
        sed -e 's:/var/lib/lunar/moonbase/::' \
            -e 's:/DETAILS::g' \
            -e 's/\/\([^/]*\)$/:\1/' \
            -e 's/\(.*\):\(.*\)/\2:\1/g' > $TMP_INDEX

  else

    # this *really* is the fastest way to do it, no guarantees, we
    # do have to make sure MOONBASE is coherent and tidy though
    debug_msg "Regenerating \$MODULE_INDEX manually..."
    find $MOONBASE -type f -name DETAILS ! -regex "$MOONBASE/zlocal/.*" \
        -printf "%h\n" |
      sed "s:$MOONBASE::;s:^/::;s:^\(.*\)/\([^/]*\)$:\2\:\1:" > $TMP_INDEX

    # also, add aliases
    find $MOONBASE -type f -name aliases | while read aliasfile; do
        sed 's/:.*/:alias/' < $aliasfile >> $TMP_INDEX
    done
  fi

  # this should be safe enough:
  sqlite3 $MODULE_STATUS "
    drop table if exists module_index;
    create table module_index (package text, location text);
    .import $TMP_INDEX module_index"

  # the old module index can still be used for its timestamp
  # (thanks, find command)
  touch $MODULE_INDEX

  # do not forget to do these at any time:
  temp_destroy $TMP_INDEX
}


# function: check_module_index
# usage   : check_module_index
# purpose : checks if the index is up-to-date regarding to moonbase
function check_module_index() {
(
  debug_msg "check_module_index ($@)"
  local RESULT=1
  local sqlite_result;
  sqlite3_ensure_schema

  if ! { sqlite_timestamp_exists "index" || sqlite_timestamp_exists "depends" }
  then
    create_module_index
    create_depends_cache
    RESULT=0
  else
    if [[ -n "$(find $MOONBASE -type f -name "DETAILS" -cnewer $MODULE_INDEX)" ]]; then
      create_module_index
      RESULT=0
    fi
    if [[ -n "$(find $MOONBASE -type f -name "DEPENDS" -cnewer $DEPENDS_CACHE)" ]]; then
      # the module index needs to be newer
      # touch will assure this
      touch $MODULE_INDEX
      create_depends_cache
      RESULT=0
    fi
  fi
  return $RESULT
)
}


# function : find_section
# usage    : find_section "module name"
# purpose  : finds the section of a given module as parameter
# returns  : (0) on success, (1) on failure, errors on stdout
find_section() {
	local SECTION SECTIONS
	debug_msg "find_section ($@)"

	# if using ZLOCAL, we must search there first
	if [[ "${ZLOCAL_OVERRIDES:-off}" == "on" ]] ; then
		for SECTION in $(find "$MOONBASE/zlocal/" -type d -name $1 | sed -e "s|$MOONBASE/||;s|/$1$||" ) ; do
			if [[ -f "$MOONBASE/$SECTION/$1/DETAILS" ]]; then
				echo $SECTION
				return 0
			fi
		done
	fi

	# otherwise check for ordinary modules named that way
	SECTION=$(sqlite3 $MODULE_INDEX \
		"select location from module_index where package = '$1'")
    # SECTION=$(awk -F: "(\$1==\"$1\"){print \$2;exit 0}" "$MODULE_INDEX")
	if [[ -n "$SECTION" ]] && [[ -d "$MOONBASE/$SECTION/$1" ]] ; then
		echo "$SECTION"
		return 0
	fi

	# assuming we're not using ZLOCAL, we haven't looked there yet!
	# perhaps it's a zlocal module ? search zlocal for it now
	if SECTION=$(find "$MOONBASE/zlocal/" -type d -name $1 | sed -e "s|$MOONBASE/||;s|/$1$||" ) ; then
		if [[ -f "$MOONBASE/zlocal/$SECTION/$1/DETAILS" ]]; then
			echo $SECTION
			return 0
		fi
	fi

	# still not found? refresh module index... this may take a while
	if ! check_module_index ; then
		# shave some time off not trying the rest of the code below since that
		# is useless
		return 1
	fi

	# and search again, this should be quick now
	SECTION=$(sqlite3 $MODULE_INDEX \
        "select location from module_index where package = '$1'")
	# SECTION=$(awk -F: "(\$1==\"$1\"){print \$2;exit 0}" "$MODULE_INDEX")
	if [[ -n "$SECTION" ]] && [[ -d "$MOONBASE/$SECTION/$1" ]] ; then
		echo "$SECTION"
		return 0
	fi

	# bummer, not found
	return 1
}


# function : run_details
# usage    : run_details module_name ($MODULE is pre-defined or param)
# purpose  : runs the DETAILS file of a module
# returns  : (0) on success, (1) on failure, error messages on stdout
run_details() {
  local TMP_DETAILS CNT TEMP SRC URLS FULL_URL IDX
  debug_msg "run_details ($@)"
  # Note: run_details doesn't EXIT the code, but merely drops a warning
  # (return 1), which means that the calling code needs to decide
  # if this is a problem or not... -sofar

  SECTION=$(find_section $1)
  if [[ -z "$SECTION" ]] ; then
    error_message  "${PROBLEM_COLOR}Unable to find module ${MODULE_COLOR}${1}${DEFAULT_COLOR}"  \
             "${PROBLEM_COLOR}in ${FILE_COLOR}$MOONBASE${DEFAULT_COLOR}"
    return 1
  else
    SCRIPT_DIRECTORY=$MOONBASE/$SECTION/$1
    if ! has_module_file $1 DETAILS ; then
      error_message  "${PROBLEM_COLOR}Module ${MODULE_COLOR}${1}" \
               "${DEFAULT_COLOR}${PROBLEM_COLOR}has no ${FILE_COLOR}DETAILS" \
               "${DEFAULT_COLOR}${PROBLEM_COLOR}file!${DEFAULT_COLOR}"
      return 1
    fi

    if [[ -z "$WANT_VERSION" ]] ; then
      run_module_file $1 DETAILS &> /dev/null || return 255
    else
      TMP_DETAILS=$(temp_create "details.version")
      if [[ -e "$MOONBASE/$SECTION/$1/DETAILS.$PLATFORM" ]]; then
        cat "$MOONBASE/$SECTION/$1/DETAILS.$PLATFORM" | sed '/^\s*VERSION=/d' > $TMP_DETAILS
      else
        cat "$MOONBASE/$SECTION/$1/DETAILS" | sed '/^\s*VERSION=/d' > $TMP_DETAILS
      fi
      VERSION="$WANT_VERSION"
      . $TMP_DETAILS &> /dev/null || return 255
      temp_destroy $TMP_DETAILS
    fi
    SOURCE_DIRECTORY=${SOURCE_DIRECTORY:-$BUILD_DIRECTORY/$1-$VERSION}
    MODULE_CONFIG=${MODULE_CONFIG:-$DEPENDS_CONFIG/$MODULE}
    MODULE_PREFIX=${MODULE_PREFIX:-$DEFAULT_PREFIX}
    if [ "$MODULE_PREFIX" != "$DEFAULT_PREFIX" ]; then
      export PKG_CONFIG_PATH=$MODULE_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH
      export PATH=$PATH:$MODULE_PREFIX/bin
    fi

    MAX_SOURCES=${MAX_SOURCES:-100}
    for (( CNT=1; CNT<=$MAX_SOURCES; CNT++ )) ; do
      TEMP=SOURCE$((CNT))
      TEMP=${TEMP/%SOURCE1/SOURCE}
      eval SRC=\${$TEMP}
      eval URLS=\${${TEMP}_URL[@]}
      FULL_URL=${TEMP}_URL_FULL

      [ -z "$SRC" ] && break
      [ -z "$URLS" ] && continue

      for IDX in ${!URLS[@]} ; do
        eval $FULL_URL[$IDX]=\${URLS\[$IDX\]}\${SRC}
      done
    done
    MAX_SOURCES=$((CNT-1))

    return 0
  fi
}


has_module_file()
{
	if [[ -e "$SCRIPT_DIRECTORY/$2" ]] || [[ -e "$SCRIPT_DIRECTORY/$2.$PLATFORM" ]]; then
		return 0
	else
		return 1
	fi
}


# function : run_module_file
# usage    : run_module_file $MODULE $SCRIPTNAME
# purpose  : runs the given script for a pre-defined module
run_module_file() {
	debug_msg "run_module_file ($@)"
	if [[ "$1" == "moonbase" ]] ; then
		return 0
	fi
	if [[ -e "$SCRIPT_DIRECTORY/$2.$PLATFORM" ]]; then
		. $SCRIPT_DIRECTORY/$2.$PLATFORM
	elif [[ -e "$SCRIPT_DIRECTORY/$2" ]]; then
		. $SCRIPT_DIRECTORY/$2
	fi
}


# function : module_installed
# usage    : module_installed $MODULE
# purpose  : check if $MODULE is installed (or held)
module_installed()
{
  debug_msg "module_installed ($@)"

  has_module_state $1 installed || has_module_state $1 held
}


# function : module_held
# usage    : module_held $MODULE
# purpose  : check if $MODULE is held
module_held() {
  debug_msg "module_held ($@)"

  has_module_state $1 held
}


module_license_accepted() {
  #
  # This code handles acceptance or rejection of certain licenses.
  #
  # valid licenses currently are:
  # osi == gpl gpl2 lgpl gfdl bsd mpl cc apache artistic qpl

  debug_msg "module_license_accepted ($@)"

  local L LICENSE IS_OSI
  LICENSE=$(run_details $1 > /dev/null ; echo $LICENSE)
  # assume it's osi if it's empty
  if [ -z "$LICENSE" ]; then
    debug_msg "assuming LICENSE=\"osi\""
    LICENSE="osi"
  fi

  # check for osi license
  case $LICENSE in
    gpl|gpl2|lgpl|gfdl|bsd|mpl|cc|apache|artistic|qpl|osi)
      IS_OSI=yes
    ;;
  esac

  # check if $MODULE's $LICENSE is accepted or not, works as follows:
  # if ACCEPTED_LICENSES is set, LICENSE *must* be listed, else if
  # REJECTED_LICESES is set, must _NOT_ be listed
  # * accept "osi" will accept all osi licenses
  # * accept "all" will accept anything
  if [[ -n "$ACCEPTED_LICENSES" ]]; then
    for L in $ACCEPTED_LICENSES; do
      if [[ "$L" == "osi" ]] && [[ "$IS_OSI" == "yes" ]] || [ "$L" == "all" ] || [ "$LICENSE" == "$L" ] ; then
        # explicitly accepted license!
	debug_msg "module_license_accepted: \"$LICENSE\" is explicitly accepted"
        return 0
      fi
    done
    # it was not explicitly accepted
    error_message "${MODULE_COLOR}$1${DEFAULT_COLOR}: ${PROBLEM_COLOR}License \"$LICENSE\" is not explicitly accepted${DEFAULT_COLOR}"
    return 1
  elif [[ -n "$REJECTED_LICENSES" ]]; then
    for L in $REJECTED_LICENSES; do
      if [[ "$LICENSE" == "$L" ]]; then
        # explicitly rejected license!
	error_message "${MODULE_COLOR}$1${DEFAULT_COLOR}: ${PROBLEM_COLOR}License \"$LICENSE\" is explicitly rejected${DEFAULT_COLOR}"
	return 1
      fi
    done
    # implicitly not rejected
    debug_msg "module_license_accepted: \"$LICENSE\" is not rejected"
    return 0
  else ## if [ -z "${ACCEPTED_LICENSES}${REJECTED_LICESES}" ]; then
    # so now we have a problem - the user didn't set their prefs
    if [[ "$IS_OSI" != "yes" ]]; then
      error_message "${MODULE_COLOR}$1${DEFAULT_COLOR}: ${PROBLEM_COLOR}License \"$LICENSE\" cannot be accepted by default${DEFAULT_COLOR}"
      return 1
    fi
  fi
}


# function : module_exiled
# usage    : module_exiled $MODULE
# purpose  : check if $MODULE is exiled
module_exiled() {
  debug_msg "module_exiled ($@)"

  has_module_state $1 exiled
}


# function : module_exiled
# usage    : module_exiled $MODULE
# purpose  : check if $MODULE is exiled
module_enforced() {
  debug_msg "module_enforced ($@)"

  has_module_state $1 enforced
}


# function : installed_version
# usage    : installed_version $MODULE
# purpose  : return the installed version of $MODULE
installed_version() {
  debug_msg "installed_version ($@)"
  sqlite3 "$MODULE_STATUS" "select version from modules where package = '$1'"
}


# display current moonbase version of $MODULE
module_version() {
  debug_msg "module_version($@)"
  (
    if run_details $1 ; then
      echo $VERSION
    else
      exit 1
    fi
  )
}


# function : hold_modules
# usage    : hold_modules $MODULE [$MODULE....]
# purpose  : put modules on hold
hold_modules() {
  local MODULE
  debug_msg "hold_modules ($@)"
  if [[ -n "$1" ]] ; then
    for MODULE in "$@" ; do
      if ! module_installed $MODULE; then
        error_message "${PROBLEM_COLOR}Cannot hold not installed module ${MODULE_COLOR}$MODULE${DEFAULT_COLOR}"
      else
        add_module_state $MODULE held
      fi
    done
  fi
}


# function : unhold_modules
# usage    : unhold_modules $MODULE [$MODULE....]
# purpose  : put modules on hold back to normal
unhold_modules () {
  local MODULE
  debug_msg "unhold_modules ($@)"
  if [[ -n "$1" ]] ; then
    for MODULE in "$@" ; do
      remove_module_state $MODULE held
    done
  fi
}


# function : exile_modules
# usage    : exile_modules $MODULE [$MODULE....]
# purpose  : put modules on exile
exile_modules() {
  local MODULE
  debug_msg "exile_modules ($@)"
  if [[ -n "$1" ]] ; then
    for MODULE in "$@" ; do
      if $(module_installed $MODULE); then
        error_message "${PROBLEM_COLOR}Cannot exile installed module ${MODULE_COLOR}$MODULE${DEFAULT_COLOR}"
      else
        change_module_state $MODULE exiled installed held enforced
      fi
    done
  fi
}


# function : unexile_modules
# usage    : unexile_modules $MODULE [$MODULE....]
# purpose  : put modules on exile back to normal
unexile_modules () {
  local MODULE
  debug_msg "unexile_modules  ($@)"
  if [ -n "$1" ] ; then
    for MODULE in "$@" ; do
      remove_module_state $MODULE exiled
    done
  fi
}


# function : enforce_modules
# usage    : enforce_modules $MODULE [$MODULE....]
# purpose  : enforce module selection
enforce_modules() {
  local MODULE
  debug_msg "enforce_modules ($@)"
  if [[ -n "$1" ]] ; then
    for MODULE in "$@" ; do
      change_module_state $MODULE enforced exiled
    done
  fi
}


# function : unenforce_modules
# usage    : unenforce_modules $MODULE [$MODULE....]
# purpose  : remove enforced module selection
unenforce_modules () {
  local MODULE
  debug_msg "unenforce_modules  ($@)"
  if [ -n "$1" ] ; then
    for MODULE in "$@" ; do
      remove_module_state $MODULE enforced
    done
  fi
}

# function : create_module_status
# usage    : create_module_status
# purpose  : create new empty module status file
create_module_status() {
    sqlite3 "$MODULE_STATUS" <<EOT
        drop table if exists modules;

        create table modules (
            package text primary key,
            date datestamp,
            version text,
            size integer
        );

        drop table if exists states;
        create table states (
            name text primary key
        );

        insert into states values ( 'installed' );
        insert into states values ( 'held' );
        insert into states values ( 'exiled' );
        insert into states values ( 'enforced' );

        drop table if exists modules_states;

        create table modules_states (
            module_id integer,
            state_id integer
        );
EOT
    touch $MODULE_STATUS $DEPENDS_STATUS $DEPENDS_STATUS_BACKUP
}

# function : remove_module
# usage    : remove_module; but $MODULE must be defined earlier
# purpose  : removed a module from the MODULE_STATUS files, no source removal
remove_module() {
  local OLD_STATE

  debug_msg "remove_module ($@)"

  # catch this on new boxes:
  if [ ! -f $MODULE_STATUS ] ; then
      create_module_status
  fi

  verbose_msg "updating lunar state files after module removal"
  sqlite3 "$MODULE_STATUS" \
    "insert into modules
         select '$1', null, null, null
         where not exists (
            select * from modules where package = '$1');
     update modules
        set version = null,
            date = null,
            size = null
        where package = '$1'"
}


# function: add_module
# usage   : add_module <module_name> <state> <version> <size>
# purpose : adds the 1st parameter as the module name to the MODULE_STATUS files
add_module()  {
  local OLD_STATE
  debug_msg "add_module ($@)"

  # catch this on new boxes:
  if [ ! -f $MODULE_STATUS ] ; then
    create_module_status
  fi

  verbose_msg "updating lunar state files after module installation"
  datestamp=$(date -u +%Y%m%d)
  sqlite3 "$MODULE_STATUS" \
      "insert into modules
           select '$1', null, null, null
           where not exists (
              select * from modules where package = '$1');"

  sqlite3 "$MODULE_STATUS" \
      "update modules
          set version = '$3',
              date = '$datestamp',
              size = $4
          where package = '$1';"
  add_module_state $1 $2
}


# function: add_module_state
# usage   : add_module_state <module_name> <state>
# purpose : adds <state> to the module. add an empty new line to the MODULE_STATUS files if net there yet
# pre     : the MODULE_STATUS files need to be locked
add_module_state() {
  debug_msg "add_module_state ($@)"

  sqlite3 "$MODULE_STATUS" \
       "begin transaction;
        insert into modules
            select '$1', null, null, null
            where not exists (
                select * from modules where package = '$1');
        insert into modules_states
            select m.rowid, s.rowid
                from modules m, states s
                where m.package = '$1' and s.name = '$2'
                and not exists (
                    select * from modules_states ms
                        inner join modules m on m.rowid = ms.module_id
                        inner join states s on s.rowid = ms.state_id
                        where m.package = '$1' and s.name = '$2');
        commit;"
}


# function: remove_module_state
# usage   : remove_module_state <module_name> <state>
# purpose : removes <state> from the module. remove the line completely from the MODULE_STATUS files if no state left
# pre     : the MODULE_STATUS files need to be locked
remove_module_state() {
  debug_msg "remove_module_state ($@)"

  sqlite3 "$MODULE_STATUS" \
      "delete from modules_states
       where module_id = ( select rowid from modules where package = '$1' )
         and state_id = ( select rowid from states where name = '$2' )"
}


# function: change_module_state
# usage   : change_module_state <module_name> <new_state> <old_state>
# purpose : removes <old_state> from the module and adds <new_state> to the module. add an empty new line to the MODULE_STATUS files if net there yet
# pre     : the MODULE_STATUS files need to be locked
change_module_state() {
  debug_msg "change_module_state ($@)"

  module=$1
  new_state=$2
  shift 2
  for old_state
  do
      remove_module_state $old_state
  done
  add_module_state $module $new_state
}


# function: has_module_state
# usage   : has_module_state <module_name> <state>
# purpose : checks for the presence of <state> the MODULE_STATUS file
has_module_state() {
  debug_msg "has_module_state ($@)"

  [[ $(sqlite3 "$MODULE_STATUS" \
      "select count(*)
        from modules_states ms
            inner join modules m on ms.module_id = m.rowid
            inner join states s on ms.state_id = s.rowid
            where s.name = '$2' and m.package = '$1'") -gt 0 ]]
}


# function: get_module_state
# usage   : get_module_state <module_name> <state>
# purpose : get the state of the module leaving out <state>
get_module_state() {
  debug_msg "get_module_state ($@)"

  echo $(sqlite3 "$MODULE_STATUS" \
    "select s.name
        from modules_states ms
            inner join modules m on ms.module_id = m.rowid
            inner join states s on ms.state_id = s.rowid
        where m.package = '$1'
            and s.name != '$2'") | tr ' ' ','
}


# function : purge_modules
# usage    : purge_modules
# purpose  : purge modules that were removed from moonbase
purge_modules() {
  local MODULE
  debug_msg "purge_modules ($@)"
  verbose_msg "Discovering modules that were removed from moonbase"
  # safetynet: don't wipe everything
  if [ $(list_moonbase | wc -l) -lt 100 ]; then
    error_message "${PROBLEM_COLOR}Error: ${DEFAULT_COLOR}${MESSAGE_COLOR} your moonbase seems damaged. Re-lin moonbase to fix.${DEFAULT_COLOR}"
    exit 1
  fi
  for MODULE in $(list_installed | fgrep -v -x moonbase) ; do
  (
    if ! run_details $MODULE &> /dev/null ; then
      message "${MODULE_COLOR}$MODULE${DEFAULT_COLOR}${MESSAGE_COLOR} was removed from ${FILE_COLOR}${MOONBASE}${DEFAULT_COLOR}"
      if query "Do you want to remove ${MODULE_COLOR}$MODULE${DEFAULT_COLOR}${QUERY_COLOR} ?" y ; then
        lrm $MODULE
        continue
      else
        message "${MODULE_COLOR}$MODULE${DEFAULT_COLOR}${MESSAGE_COLOR} is kept and can be removed manually later${DEFAULT_COLOR}"
      fi
    fi
  )
  done
}


module_is_expired() {
  debug_msg "module_is_expired ($@)"
  (
    if [ -z "$MODULE" ] ; then
      MODULE=$1
    fi
    if [ "$MODULE" == moonbase ] ; then
      return 255
    fi
    LINE=$(module_installed $MODULE && module_held $MODULE ||
           sqlite3 -separator ' ' "$MODULE_STATUS" \
               "select 'IDATE=' || date || ' IVERSION=' || version
                    from modules
                    where package = '$MODULE'")

    if [ -n "$LINE" ] ; then
      eval $LINE
      if run_details $MODULE &> /dev/null ; then
        if [[ "$VERSION" != "$IVERSION" ]] || [[ -z "$IDATE" ]] ||
	  (( "$UPDATED" > "$IDATE" )) ; then
	  return 0
	fi
      fi
    fi
    # nope... it's not expired
    return 255
  )
}


# function : list_expired_modules
# usage    : list_expired_modules
# purpose  : return a list of modules that need to be updated
list_expired_modules() {
  local MODULE
  debug_msg "list_expired_modules ($@)"
  for MODULE in $(list_installed) ; do
    if $(module_is_expired $MODULE) ; then
      echo "$MODULE"
    fi
  done
}


# function : update_modules
# usage    : update_modules
# purpose  : update all installed modules that need to be updated
update_modules() {
  local IFS LIST QUEUE MODULE
  debug_msg "update_modules ($@)"

  export IFS="$STANDARD_IFS"

  verbose_msg "Searching for modules to update"
  LIST=$(list_expired_modules)

  if [ -z "$LIST" ] ; then
    verbose_msg "Nothing to update!"
    return 255
  fi

  verbose_msg "Rework all module dependencies"
  for MODULE in $LIST ; do
    rework_module $MODULE
  done

  verbose_msg "Checking for lunar or theedge"
  for MODULE in $LIST ; do
    if [[ "$MODULE" == "lunar" ]] || [[ "$MODULE" == "theedge" ]] ; then
      message "${MODULE_COLOR}$MODULE${MESSAGE_COLOR} will be updated${DEFAULT_COLOR}"
      message "${MESSAGE_COLOR}Run lunar renew afterwards to update other modules${DEFAULT_COLOR}"
      if query "Do you wish to continue ? " y ; then
	lin -c $MODULE
	exit $?
      fi
      return 255
    fi
  done

  verbose_msg "Sorting update queue"
  QUEUE=$(sort_by_dependency $LIST)

  message "${MESSAGE_COLOR}The following modules will be updated:${DEFAULT_COLOR}"
  TMP_QUEUE=$(temp_create "update-queue")
  for MODULE in $QUEUE ; do
    echo $MODULE >> $TMP_QUEUE
    echo $MODULE
  done

  unset MODULE
  if query "Do you wish to edit the update queue ? " n ; then
    edit_file $TMP_QUEUE
  fi
  QUEUE=$(cat "$TMP_QUEUE")
  temp_destroy $TMP_QUEUE

  if [ -n "$QUEUE" ] ; then
    lin -c $QUEUE
  else
    verbose_msg "Nothing to update!"
    return 255
  fi
}



check_blacklist() {
  debug_msg "check_blacklist ($@)"
  if [ -f /var/state/lunar/blacklist.$PLATFORM ] ; then
    if grep "^$MODULE$" "/var/state/lunar/blacklist.$PLATFORM" ; then
      error_message "${PROBLEM_COLOR}ERROR:${DEFAULT_COLOR}${MESSAGE_COLOR} Module ${DEFAULT_COLOR}${MODULE_COLOR}$MODULE${DEFAULT_COLOR}${MESSAGE_COLOR} is blacklisted and will not be installed!${DEFAULT_COLOR}"
      exit 0
    fi
  fi
}


